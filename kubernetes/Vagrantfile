# -*- mode: ruby -*-
# vi: set ft=ruby :

#
#	Ubuntu Xenial 64-bit Linux mit Docker
#

Vagrant.configure("2") do |config|

  config.vm.box = "ubuntu/xenial64"

  # resize hd, need a plugin vagrant-disksize, see https://github.com/sprotheroe/vagrant-disksize
  # config.disksize.size = '30GB'

  # Create forwarded port mapping which allows access to a specific port
  # kubectl api port
  # config.vm.network "forwarded_port", guest:8443, host:8443, auto_correct: false
  # minikube dashboard port
  # config.vm.network "forwarded_port", guest:30000, host:30000, auto_correct: false
    
  # Create a private network, which allows host-only access to the machine
  # using a specific IP.
  config.vm.hostname = "kube"
  config.vm.network "private_network", ip:"192.168.99.100"

  # Public IP
  # config.vm.network "public_network", ip: "10.1.66.13"
  # default router TBZ.
  # config.vm.provision "shell",
  #   run: "always",
  #  inline: "route add default gw 10.1.66.254 enp0s8"
      
  config.vm.provider "virtualbox" do |vb|
     vb.memory = "2048"
  end

  # Docker Provisioner
  config.vm.provision "docker" do |d|
  end
  
config.vm.provision "shell", inline: <<-SHELL 
    # Debug ON!!!
    set -o xtrace
	
	# Docker Daemon absichern
	wget https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64 -O cfssljson
	wget https://pkg.cfssl.org/R1.2/cfssl_linux-amd64 -O cfssl
	sudo chmod +x cfssljson cfssl
	sudo mv cfssljson cfssl /usr/local/bin
	cd /vagrant/csr
	cfssl gencert -initca ca-csr.json | cfssljson -bare ca
	cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=server docker-server-csr.json | cfssljson -bare docker-server
    cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=client docker-client-csr.json | cfssljson -bare docker-client
	sudo cp ca.pem /etc/docker/ca.pem
	sudo mv docker-server-key.pem /etc/docker/server-key.pem
	sudo mv docker-server.pem /etc/docker/server.pem
	sudo chmod 0600 /etc/docker/*.pem
	sudo chown root:root /etc/docker/*.pem
	mkdir -p /home/vagrant/.docker
	mv ca.pem /home/vagrant/.docker/
    mv docker-client.pem /home/vagrant/.docker/cert.pem
    mv docker-client-key.pem /home/vagrant/.docker/key.pem
    chmod 0600 /home/vagrant/.docker/*.pem
    chmod 0700 /home/vagrant/.docker
    chown vagrant:vagrant /home/vagrant/.docker
    sudo cp -rp /home/vagrant/.docker /vagrant/
	sudo cat > /etc/systemd/system/docker.service <<%EOF%
[Service]
Type=notify
# the default is not to use systemd for cgroups because the delegate issues still
# exists and systemd currently does not support the cgroup feature set required
# for containers run by docker
ExecStart=/usr/bin/dockerd --tlsverify --tlscacert=/etc/docker/ca.pem --tlscert=/etc/docker/server.pem \
--tlskey=/etc/docker/server-key.pem -H=0.0.0.0:2376 -H fd://
ExecReload=/bin/kill -s HUP $MAINPID
LimitNOFILE=1048576
# Having non-zero Limit*s causes performance problems due to accounting overhead
# in the kernel. We recommend using cgroups to do container-local accounting.
LimitNPROC=infinity
LimitCORE=infinity
# Uncomment TasksMax if your systemd version supports it.
# Only systemd 226 and above support this version.
TasksMax=infinity
TimeoutStartSec=0
# set delegate yes so that systemd does not reset the cgroups of docker containers
Delegate=yes
# kill only the docker process, not all processes in the cgroup
KillMode=process
# restart the docker process if it exits prematurely
Restart=on-failure
StartLimitBurst=3
StartLimitInterval=60s

[Install]
WantedBy=multi-user.target
%EOF%

	sudo systemctl daemon-reload
	sudo systemctl restart docker
	export DOCKER_HOST="tcp://127.0.0.1:2376" DOCKER_TLS_VERIFY=1
    
	# install kubernetes    
	curl -Lo kubectl https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl && chmod +x kubectl
	curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64 && chmod +x minikube
	
	export MINIKUBE_WANTUPDATENOTIFICATION=false
	export MINIKUBE_WANTREPORTERRORPROMPT=false
	export MINIKUBE_HOME=/home/vagrant
	export CHANGE_MINIKUBE_NONE_USER=false
	mkdir $MINIKUBE_HOME/.kube || true
	touch $MINIKUBE_HOME/.kube/config
	
	export KUBECONFIG=$MINIKUBE_HOME/.kube/config
	sudo -E ./minikube start --vm-driver=none
	
	# this for loop waits until kubectl can access the api server that Minikube has created
	for i in {1..150}; do # timeout for 5 minutes
	   ./kubectl get po &> /dev/null
	   if [ $? -ne 1 ]; then
	      break
	  fi
	  sleep 2
	done
	
	# kubectl commands are now able to interact with Minikube cluster   
	sudo mv kubectl minikube /usr/local/bin 
	sudo chown -R vagrant:vagrant /home/vagrant/.kube /home/vagrant/.minikube	
	
	# delete default-token - no access to dashboard
	# sleep 20
	# kubectl -n kube-system delete secret `kubectl -n kube-system get secret | grep default-token | awk '{ print $1}'`
	# kubectl create -f /vagrant/account.yaml
	# kubectl create -f /vagrant/role.yaml
	# print access token - new access to dashboard
	# kubectl -n kube-system describe secret $(kubectl -n kube-system get secret | grep admin-user | awk '{print $1}')
SHELL
end
